#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');

const { Orchestrator } = require('../src/core/orchestrator');
const { Reporter } = require('../src/utils/reporter');
const { Validator } = require('../src/utils/validator');
const { TaskDescriptor } = require('../src/core/task-descriptor');
const spinner = require('../src/utils/spinner');
const packageJson = require('../package.json');

// File-scoped logging methods
const log = {
  info: (message) => console.log(chalk.blue(message)),
  success: (message) => console.log(chalk.green(message)),
  error: (message) => console.error(chalk.red(message)),
  warn: (message) => console.log(chalk.yellow(message)),
  detail: (message) => console.log(chalk.cyan(message)),
  plain: (message) => console.log(message),
  json: (data) => console.log(JSON.stringify(data, null, 2)),
  divider: (length = 50) => console.log(chalk.gray('‚îÄ'.repeat(length))),
  errorWithDetail: (prefix, error) => console.error(chalk.red(prefix), error.message),
  statusMessage: (label, value) => console.log(`${label}: ${value}`),
  listItem: (index, message) => console.log(`  ${index}. ${message}`),
  heading: (title) => {
    console.log(chalk.blue(title));
    console.log(chalk.gray('‚îÄ'.repeat(50)));
  }
};

program
  .name('nightly-code')
  .description('Automated 8-hour coding sessions using Claude Code')
  .version(packageJson.version);

program
  .command('init')
  .description('Initialize configuration in current repository')
  .option('-f, --force', 'Overwrite existing configuration')
  .option('-t, --template <type>', 'Use predefined template (node, python, go)', 'node')
  .option('--superclaude', 'Enable SuperClaude Framework integration')
  .action(async (options) => {
    try {
      const configPath = path.join(process.cwd(), 'nightly-code.yaml');
      const tasksPath = path.join(process.cwd(), 'nightly-tasks.yaml');

      // Check for existing configuration
      if (!options.force && (await fs.pathExists(configPath) || await fs.pathExists(tasksPath))) {
        log.error('Configuration already exists. Use --force to overwrite.');
        process.exit(1);
      }

      // Initialize with spinner
      await spinner.execute(
        'Initializing Nightly Code configuration...',
        async () => {
          const templateDir = path.join(__dirname, '..', 'templates');
          await fs.copy(path.join(templateDir, 'session-config.yaml'), configPath);
          await fs.copy(path.join(templateDir, 'task-template.yaml'), tasksPath);

          // Add SuperClaude configuration if requested
          if (options.superclaude) {
            spinner.update('Configuring SuperClaude integration...');
            const YAML = require('yaml');
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = YAML.parse(configContent);

            config.superclaude = {
              enabled: true,
              planning_mode: 'intelligent',
              execution_mode: 'assisted',
              task_management: 'hierarchical',
              integration_level: 'deep'
            };

            await fs.writeFile(configPath, YAML.stringify(config));
          }
        },
        {
          successText: '‚úÖ Configuration initialized successfully!'
        }
      );

      log.warn(`üìù Edit ${configPath} and ${tasksPath} to customize your setup`);

      if (options.superclaude) {
        log.detail('üß† SuperClaude Framework features:');
        log.detail('   - Intelligent task planning with slash commands');
        log.detail('   - Advanced orchestration and execution strategies');
        log.detail('   - Deep integration with nightly workflow');
        log.detail('   - Uses global SuperClaude commands (no local commands_path required)');
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Initialization failed:', error);
      process.exit(1);
    }
  });

program
  .command('schedule')
  .description('Set up automated scheduling (cron/Task Scheduler)')
  .option('-c, --cron <expression>', 'Cron expression for scheduling', '0 22 * * *')
  .option('-t, --timezone <tz>', 'Timezone for scheduling', 'UTC')
  .option('--dry-run', 'Show what would be scheduled without creating it')
  .action(async (options) => {
    try {
      log.info('‚è∞ Setting up automated scheduling...');

      const setupScript = require('../scripts/setup-cron');
      await setupScript.configure({
        cron: options.cron,
        timezone: options.timezone,
        dryRun: options.dryRun
      });

      if (!options.dryRun) {
        log.success('‚úÖ Scheduling configured successfully!');
        log.warn(`Next run: ${options.cron} (${options.timezone})`);
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Scheduling setup failed:', error);
      process.exit(1);
    }
  });

program
  .command('run')
  .description('Execute a single coding session manually')
  .option('-c, --config <path>', 'Path to configuration file', 'nightly-code.yaml')
  .option('-t, --tasks <path>', 'Path to tasks file', 'nightly-tasks.yaml')
  .option('--max-duration <minutes>', 'Maximum session duration in minutes', '480')
  .option('--dry-run', 'Validate configuration without executing')
  .option('--resume <checkpoint>', 'Resume from checkpoint')
  .option('--superclaude', 'Enable SuperClaude prompt optimization (overrides config)')
  .option('--session-pr', 'Use session-based PR strategy (one PR for all tasks)')
  .option('--task-pr', 'Use task-based PR strategy (one PR per task) - default')
  .action(async (options) => {
    try {
      // Determine PR strategy from CLI flags
      let prStrategy;
      if (options.sessionPr) {
        prStrategy = 'session';
      } else if (options.taskPr) {
        prStrategy = 'task';
      }

      const orchestrator = new Orchestrator({
        configPath: options.config,
        tasksPath: options.tasks,
        maxDuration: parseInt(options.maxDuration) * 60, // Convert to seconds
        dryRun: options.dryRun,
        resumeCheckpoint: options.resume,
        forceSuperclaude: options.superclaude, // CLI flag overrides config
        prStrategy // Pass PR strategy if specified
      });

      const sessionType = options.dryRun ? 'dry-run validation' : 'coding session';

      // Enable quiet mode since orchestrator uses pretty logger
      spinner.setQuietMode(true);

      const result = await spinner.execute(
        `Starting ${sessionType}...`,
        orchestrator.run(),
        {
          successText: options.dryRun ? '‚úÖ Validation completed successfully!' : '‚úÖ Session completed successfully!'
        }
      );

      if (result.success) {
        log.info(`üìä Completed ${result.completedTasks}/${result.totalTasks} tasks`);
        log.info(`‚è±Ô∏è  Duration: ${Math.round(result.duration / 60000)} minutes`);
      } else {
        log.warn('‚ö†Ô∏è  Session completed with issues');
        log.error(`‚ùå Errors: ${result.errors.length}`);
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Session failed:', error);
      process.exit(1);
    }
  });

program
  .command('status')
  .description('Check last session results')
  .option('-v, --verbose', 'Show detailed status information')
  .option('--json', 'Output in JSON format')
  .action(async (options) => {
    try {
      const reporter = new Reporter();
      const status = await spinner.execute(
        'Retrieving session status...',
        reporter.getLastSessionStatus(),
        {
          successText: 'üìä Status retrieved successfully'
        }
      );

      if (options.json) {
        log.json(status);
        return;
      }

      log.heading('üìä Last Session Status');

      if (!status) {
        log.warn('No previous sessions found');
        return;
      }

      log.statusMessage('Status', status.success ? chalk.green('‚úÖ Success') : chalk.red('‚ùå Failed'));
      log.statusMessage('Date', chalk.cyan(new Date(status.timestamp).toLocaleString()));
      log.statusMessage('Duration', `${chalk.cyan(Math.round(status.duration / 60))} minutes`);
      log.statusMessage('Tasks', `${chalk.cyan(status.completedTasks)}/${chalk.cyan(status.totalTasks)} completed`);

      if (options.verbose && status.errors?.length > 0) {
        log.plain(`\n${chalk.red('Errors:')}`);
        status.errors.forEach((error, i) => {
          log.listItem(i + 1, error);
        });
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Failed to get status:', error);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Manage configuration interactively')
  .option('-l, --list', 'List current configuration')
  .option('-e, --edit', 'Edit configuration interactively')
  .option('-v, --validate', 'Validate current configuration')
  .action(async (options) => {
    try {
      const validator = new Validator();

      if (options.list) {
        const config = await validator.loadConfig();
        log.heading('Current Configuration:');
        log.json(config);
        return;
      }

      if (options.validate) {
        const validation = await validator.validateAll();
        if (validation.valid) {
          log.success('‚úÖ Configuration is valid');
        } else {
          log.error('‚ùå Configuration has errors:');
          validation.errors.forEach(error => log.plain(`  - ${error}`));
          process.exit(1);
        }
        return;
      }

      if (options.edit) {
        log.info('üîß Interactive Configuration Editor');
        // Interactive configuration editing would go here
        log.warn('Interactive editing not yet implemented');
        return;
      }

      // Default action - show help
      program.commands.find(cmd => cmd.name() === 'config').help();
    } catch (error) {
      log.errorWithDetail('‚ùå Configuration management failed:', error);
      process.exit(1);
    }
  });

program
  .command('validate')
  .description('Validate current configuration')
  .option('-c, --config <path>', 'Path to configuration file', 'nightly-code.yaml')
  .option('-t, --tasks <path>', 'Path to tasks file', 'nightly-tasks.yaml')
  .option('--fix', 'Attempt to fix common issues')
  .action(async (options) => {
    try {
      const validator = new Validator({
        configPath: options.config,
        tasksPath: options.tasks
      });

      // Enable quiet mode to work with pretty logger
      spinner.setQuietMode(true);

      const result = await spinner.execute(
        'Validating configuration...',
        validator.validateAll(),
        {
          successText: '‚úÖ All validations passed!'
        }
      );

      if (!result.valid) {
        spinner.fail('‚ùå Validation failed');
        result.errors.forEach(error => {
          log.plain(`  - ${error.message} (${error.path})`);
        });

        if (options.fix) {
          const fixResult = await spinner.execute(
            'Attempting to fix issues...',
            validator.attemptFix(result.errors),
            {
              successText: `‚úÖ Fixed ${result.fixed || 0} issues`
            }
          );

          if (fixResult.remaining > 0) {
            log.warn(`‚ö†Ô∏è  ${fixResult.remaining} issues require manual intervention`);
          }
        }

        process.exit(result.errors.length);
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Validation failed:', error);
      process.exit(1);
    }
  });

program
  .command('report')
  .description('View session reports')
  .argument('[date]', 'Date for report (YYYY-MM-DD)', new Date().toISOString().split('T')[0])
  .option('-f, --format <type>', 'Output format (json, markdown, table)', 'table')
  .option('-o, --output <file>', 'Output file path')
  .option('--last <count>', 'Show last N sessions', '10')
  .action(async (date, options) => {
    try {
      log.info(`üìà Generating report for ${date}...`);

      const reporter = new Reporter();
      const report = await reporter.generateReport({
        date,
        format: options.format,
        last: parseInt(options.last)
      });

      if (options.output) {
        await fs.writeFile(options.output, report);
        log.success(`‚úÖ Report saved to ${options.output}`);
      } else {
        log.plain(report);
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Report generation failed:', error);
      process.exit(1);
    }
  });

program
  .command('describe')
  .description('Describe work to be done in natural language and generate nightly-tasks.yaml')
  .option('-o, --output <file>', 'Output file path', 'nightly-tasks.yaml')
  .option('-i, --interactive', 'Interactive mode for entering multiple tasks')
  .option('-f, --file <path>', 'Read descriptions from a text file')
  .option('--append', 'Append to existing tasks file instead of overwriting')
  .action(async (options) => {
    try {
      log.info('üìù Task Description Mode');
      log.plain(chalk.gray(
        'Describe the work to be done in natural language. Claude will convert it into optimized tasks.\n'
      ));

      const taskDescriptor = new TaskDescriptor();
      const { input, editor, confirm } = require('@inquirer/prompts');
      let descriptions = [];

      if (options.file) {
        // Read descriptions from file
        const content = await fs.readFile(options.file, 'utf8');
        descriptions = content.split('\n\n').filter(desc => desc.trim());
        log.success(`‚úÖ Loaded ${descriptions.length} task descriptions from file`);
      } else if (options.interactive) {
        // Interactive mode
        log.warn('Enter task descriptions. Type "done" to finish.\n');

        let done = false;
        while (!done) {
          let description;

          try {
            description = await editor({
              message: 'Describe the task (press Enter to open editor):',
              validate: (input) => {
                if (!input || input.trim() === '') {
                  return 'Description cannot be empty';
                }
                return true;
              }
            });
          } catch (error) {
            // Fallback to simple input if editor fails
            log.warn('Editor not available, using simple input mode');
            description = await input({
              message: 'Describe the task:',
              validate: (input) => {
                if (!input || input.trim() === '') {
                  return 'Description cannot be empty';
                }
                return true;
              }
            });
          }

          if (description.toLowerCase().trim() === 'done') {
            done = true;
          } else {
            descriptions.push(description);
            log.success(`‚úÖ Task ${descriptions.length} added`);

            const shouldContinue = await confirm({
              message: 'Add another task?',
              default: true
            });

            if (!shouldContinue) done = true;
          }
        }
      } else {
        // Single task mode from command line arguments
        const args = program.args.slice(1); // Skip 'describe' command
        if (args.length === 0) {
          log.warn('Please provide a task description or use --interactive mode');
          log.plain(chalk.gray('\nExamples:'));
          log.plain(chalk.gray('  nightly-code describe "Implement user authentication with email verification"'));
          log.plain(chalk.gray('  nightly-code describe --interactive'));
          log.plain(chalk.gray('  nightly-code describe --file tasks.txt'));
          process.exit(1);
        }
        descriptions = [args.join(' ')];
      }

      if (descriptions.length === 0) {
        log.warn('No task descriptions provided');
        process.exit(1);
      }

      // Process descriptions with automatic splitting
      const progress = spinner.createProgress([
        'Processing task descriptions',
        'Applying auto-splitting logic',
        'Generating optimized tasks',
        'Writing output file'
      ]);

      // Track splitting results
      let totalTasks = 0;
      let splitCount = 0;

      progress.next();
      let yamlContent;

      if (options.append && await fs.pathExists(options.output)) {
        // Load existing tasks
        const existingContent = await fs.readFile(options.output, 'utf8');
        const YAML = require('yaml');
        const existing = YAML.parse(existingContent);

        // Add new tasks with automatic splitting
        const newTasks = [];
        descriptions.forEach(desc => {
          const result = taskDescriptor.parseDescription(desc);
          if (Array.isArray(result)) {
            // Task was split
            splitCount++;
            result.forEach(task => newTasks.push(taskDescriptor.optimizeTask(task)));
          } else {
            // Single task
            newTasks.push(taskDescriptor.optimizeTask(result));
          }
        });
        totalTasks = newTasks.length;

        existing.tasks = existing.tasks.concat(newTasks);

        // Sort all tasks by priority
        existing.tasks.sort((a, b) => b.priority - a.priority);

        yamlContent = YAML.stringify(existing, {
          indent: 2,
          lineWidth: 0
        });
      } else {
        // Generate new file with splitting tracking
        yamlContent = taskDescriptor.generateTasksYaml(descriptions);
        const YAML = require('yaml');
        const parsedContent = YAML.parse(yamlContent);
        totalTasks = parsedContent.tasks.length;
        splitCount = parsedContent.metadata?.auto_split_applied ? 1 : 0;
      }

      // Write output
      await fs.writeFile(options.output, yamlContent);
      log.success(`\n‚úÖ Tasks written to ${options.output}`);

      // Show splitting summary
      if (splitCount > 0) {
        log.detail(
          `üîÑ Auto-split applied: ${splitCount} complex descriptions split into ${totalTasks} tasks`
        );
      }

      // Show summary
      const YAML = require('yaml');
      const tasks = YAML.parse(yamlContent).tasks;
      log.heading('\nüìä Task Summary:');

      tasks.forEach((task, index) => {
        const priority = task.priority >= 8
          ? chalk.red(`[P${task.priority}]`)
          : task.priority >= 6
            ? chalk.yellow(`[P${task.priority}]`)
            : chalk.green(`[P${task.priority}]`);
        log.plain(`${index + 1}. ${priority} ${task.title}`);
        log.plain(
          `   Type: ${chalk.cyan(task.type)}, Min Duration: ${chalk.cyan(task.minimum_duration ? `${task.minimum_duration} min` : 'none')}, ` +
          `Tags: ${chalk.gray(task.tags.join(', '))}`
        );
      });

      const totalDuration = tasks.reduce((sum, task) => sum + (task.minimum_duration || 0), 0);
      log.divider();
      log.info(
        `Total estimated duration: ${Math.round(totalDuration / 60)} hours ${totalDuration % 60} minutes`
      );

      // Show task IDs for reference
      log.plain(chalk.gray('\nTask IDs for reference:'));
      tasks.slice(0, 5).forEach(task => {
        log.plain(chalk.gray(`  ${task.id}`));
      });
      if (tasks.length > 5) {
        log.plain(chalk.gray(`  ... and ${tasks.length - 5} more`));
      }
    } catch (error) {
      log.errorWithDetail('‚ùå Task description failed:', error);
      process.exit(1);
    }
  });

// Error handling
program.on('command:*', () => {
  log.error(`Invalid command: ${program.args.join(' ')}`);
  log.warn('See --help for available commands');
  process.exit(1);
});

// Global error handler
process.on('uncaughtException', (error) => {
  log.errorWithDetail('‚ùå Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  log.error(`‚ùå Unhandled Rejection at: ${promise}, reason: ${reason}`);
  process.exit(1);
});

program.parse();
