#!/usr/bin/env node

const { program } = require('commander');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');

const { Orchestrator } = require('../src/orchestrator');
const { Reporter } = require('../src/reporter');
const { Validator } = require('../src/validator');
const { TaskDescriptor } = require('../src/task-descriptor');
const packageJson = require('../package.json');

program
  .name('nightly-code')
  .description('Automated 8-hour coding sessions using Claude Code')
  .version(packageJson.version);

program
  .command('init')
  .description('Initialize configuration in current repository')
  .option('-f, --force', 'Overwrite existing configuration')
  .option('-t, --template <type>', 'Use predefined template (node, python, go)', 'node')
  .option('--superclaude', 'Enable SuperClaude Framework integration')
  .action(async (options) => {
    try {
      console.log(chalk.blue('üöÄ Initializing Nightly Code configuration...'));

      const configPath = path.join(process.cwd(), 'nightly-code.yaml');
      const tasksPath = path.join(process.cwd(), 'nightly-tasks.yaml');

      if (!options.force && (await fs.pathExists(configPath) || await fs.pathExists(tasksPath))) {
        console.error(chalk.red('Configuration already exists. Use --force to overwrite.'));
        process.exit(1);
      }

      // Copy templates based on project type
      const templateDir = path.join(__dirname, '..', 'templates');
      await fs.copy(path.join(templateDir, 'session-config.yaml'), configPath);
      await fs.copy(path.join(templateDir, 'task-template.yaml'), tasksPath);

      // Add SuperClaude configuration if requested
      if (options.superclaude) {
        const YAML = require('yaml');
        const configContent = await fs.readFile(configPath, 'utf8');
        const config = YAML.parse(configContent);

        // Add SuperClaude configuration section
        config.superclaude = {
          enabled: true,
          // commands_path: './superclaude/commands/sc', // Optional: if not specified, assumes global SuperClaude commands
          planning_mode: 'intelligent',
          execution_mode: 'assisted',
          task_management: 'hierarchical',
          integration_level: 'deep'
        };

        await fs.writeFile(configPath, YAML.stringify(config));
        console.log(chalk.green('‚úÖ SuperClaude Framework integration enabled!'));
      }

      console.log(chalk.green('‚úÖ Configuration initialized successfully!'));
      console.log(chalk.yellow(`üìù Edit ${configPath} and ${tasksPath} to customize your setup`));

      if (options.superclaude) {
        console.log(chalk.cyan('üß† SuperClaude Framework features:'));
        console.log(chalk.cyan('   - Intelligent task planning with slash commands'));
        console.log(chalk.cyan('   - Advanced orchestration and execution strategies'));
        console.log(chalk.cyan('   - Deep integration with nightly workflow'));
        console.log(chalk.cyan('   - Uses global SuperClaude commands (no local commands_path required)'));
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Initialization failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('schedule')
  .description('Set up automated scheduling (cron/Task Scheduler)')
  .option('-c, --cron <expression>', 'Cron expression for scheduling', '0 22 * * *')
  .option('-t, --timezone <tz>', 'Timezone for scheduling', 'UTC')
  .option('--dry-run', 'Show what would be scheduled without creating it')
  .action(async (options) => {
    try {
      console.log(chalk.blue('‚è∞ Setting up automated scheduling...'));

      const setupScript = require('../scripts/setup-cron');
      await setupScript.configure({
        cron: options.cron,
        timezone: options.timezone,
        dryRun: options.dryRun
      });

      if (!options.dryRun) {
        console.log(chalk.green('‚úÖ Scheduling configured successfully!'));
        console.log(chalk.yellow(`Next run: ${options.cron} (${options.timezone})`));
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Scheduling setup failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('run')
  .description('Execute a single coding session manually')
  .option('-c, --config <path>', 'Path to configuration file', 'nightly-code.yaml')
  .option('-t, --tasks <path>', 'Path to tasks file', 'nightly-tasks.yaml')
  .option('--max-duration <minutes>', 'Maximum session duration in minutes', '480')
  .option('--dry-run', 'Validate configuration without executing')
  .option('--resume <checkpoint>', 'Resume from checkpoint')
  .option('--superclaude', 'Enable SuperClaude prompt optimization (overrides config)')
  .option('--session-pr', 'Use session-based PR strategy (one PR for all tasks)')
  .option('--task-pr', 'Use task-based PR strategy (one PR per task) - default')
  .action(async (options) => {
    try {
      console.log(chalk.blue('üéØ Starting coding session...'));

      // Determine PR strategy from CLI flags
      let prStrategy;
      if (options.sessionPr) {
        prStrategy = 'session';
      } else if (options.taskPr) {
        prStrategy = 'task';
      }
      // If neither flag is specified, will default to config or 'task'

      const orchestrator = new Orchestrator({
        configPath: options.config,
        tasksPath: options.tasks,
        maxDuration: parseInt(options.maxDuration) * 60, // Convert to seconds
        dryRun: options.dryRun,
        resumeCheckpoint: options.resume,
        forceSuperclaude: options.superclaude, // CLI flag overrides config
        prStrategy // Pass PR strategy if specified
      });

      const result = await orchestrator.run();

      if (result.success) {
        console.log(chalk.green('‚úÖ Session completed successfully!'));
        console.log(chalk.blue(`üìä Completed ${result.completedTasks}/${result.totalTasks} tasks`));
        console.log(chalk.blue(`‚è±Ô∏è  Duration: ${Math.round(result.duration / 60000)} minutes`));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Session completed with issues'));
        console.log(chalk.red(`‚ùå Errors: ${result.errors.length}`));
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Session failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('status')
  .description('Check last session results')
  .option('-v, --verbose', 'Show detailed status information')
  .option('--json', 'Output in JSON format')
  .action(async (options) => {
    try {
      const reporter = new Reporter();
      const status = await reporter.getLastSessionStatus();

      if (options.json) {
        console.log(JSON.stringify(status, null, 2));
        return;
      }

      console.log(chalk.blue('üìä Last Session Status'));
      console.log('‚îÄ'.repeat(50));

      if (!status) {
        console.log(chalk.yellow('No previous sessions found'));
        return;
      }

      console.log(`Status: ${status.success ? chalk.green('‚úÖ Success') : chalk.red('‚ùå Failed')}`);
      console.log(`Date: ${chalk.cyan(new Date(status.timestamp).toLocaleString())}`);
      console.log(`Duration: ${chalk.cyan(Math.round(status.duration / 60))} minutes`);
      console.log(`Tasks: ${chalk.cyan(status.completedTasks)}/${chalk.cyan(status.totalTasks)} completed`);

      if (options.verbose && status.errors?.length > 0) {
        console.log(`\n${chalk.red('Errors:')}`);
        status.errors.forEach((error, i) => {
          console.log(`  ${i + 1}. ${error}`);
        });
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Failed to get status:'), error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Manage configuration interactively')
  .option('-l, --list', 'List current configuration')
  .option('-e, --edit', 'Edit configuration interactively')
  .option('-v, --validate', 'Validate current configuration')
  .action(async (options) => {
    try {
      const validator = new Validator();

      if (options.list) {
        const config = await validator.loadConfig();
        console.log(chalk.blue('Current Configuration:'));
        console.log('‚îÄ'.repeat(50));
        console.log(JSON.stringify(config, null, 2));
        return;
      }

      if (options.validate) {
        const validation = await validator.validateAll();
        if (validation.valid) {
          console.log(chalk.green('‚úÖ Configuration is valid'));
        } else {
          console.log(chalk.red('‚ùå Configuration has errors:'));
          validation.errors.forEach(error => console.log(`  - ${error}`));
          process.exit(1);
        }
        return;
      }

      if (options.edit) {
        console.log(chalk.blue('üîß Interactive Configuration Editor'));
        // Interactive configuration editing would go here
        console.log(chalk.yellow('Interactive editing not yet implemented'));
        return;
      }

      // Default action - show help
      program.commands.find(cmd => cmd.name() === 'config').help();
    } catch (error) {
      console.error(chalk.red('‚ùå Configuration management failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('validate')
  .description('Validate current configuration')
  .option('-c, --config <path>', 'Path to configuration file', 'nightly-code.yaml')
  .option('-t, --tasks <path>', 'Path to tasks file', 'nightly-tasks.yaml')
  .option('--fix', 'Attempt to fix common issues')
  .action(async (options) => {
    try {
      console.log(chalk.blue('üîç Validating configuration...'));

      const validator = new Validator({
        configPath: options.config,
        tasksPath: options.tasks
      });

      const result = await validator.validateAll();

      if (result.valid) {
        console.log(chalk.green('‚úÖ All validations passed!'));
      } else {
        console.log(chalk.red('‚ùå Validation failed:'));
        result.errors.forEach(error => {
          console.log(`  - ${error.message} (${error.path})`);
        });

        if (options.fix) {
          console.log(chalk.yellow('üîß Attempting to fix issues...'));
          const fixResult = await validator.attemptFix(result.errors);
          if (fixResult.fixed > 0) {
            console.log(chalk.green(`‚úÖ Fixed ${fixResult.fixed} issues`));
          }
          if (fixResult.remaining > 0) {
            console.log(chalk.yellow(`‚ö†Ô∏è  ${fixResult.remaining} issues require manual intervention`));
          }
        }

        process.exit(result.errors.length);
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Validation failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('report')
  .description('View session reports')
  .argument('[date]', 'Date for report (YYYY-MM-DD)', new Date().toISOString().split('T')[0])
  .option('-f, --format <type>', 'Output format (json, markdown, table)', 'table')
  .option('-o, --output <file>', 'Output file path')
  .option('--last <count>', 'Show last N sessions', '10')
  .action(async (date, options) => {
    try {
      console.log(chalk.blue(`üìà Generating report for ${date}...`));

      const reporter = new Reporter();
      const report = await reporter.generateReport({
        date,
        format: options.format,
        last: parseInt(options.last)
      });

      if (options.output) {
        await fs.writeFile(options.output, report);
        console.log(chalk.green(`‚úÖ Report saved to ${options.output}`));
      } else {
        console.log(report);
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Report generation failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('describe')
  .description('Describe work to be done in natural language and generate nightly-tasks.yaml')
  .option('-o, --output <file>', 'Output file path', 'nightly-tasks.yaml')
  .option('-i, --interactive', 'Interactive mode for entering multiple tasks')
  .option('-f, --file <path>', 'Read descriptions from a text file')
  .option('--append', 'Append to existing tasks file instead of overwriting')
  .action(async (options) => {
    try {
      console.log(chalk.blue('üìù Task Description Mode'));
      console.log(chalk.gray(
        'Describe the work to be done in natural language. Claude will convert it into optimized tasks.\n'
      ));

      const taskDescriptor = new TaskDescriptor();
      const inquirer = require('inquirer');
      let descriptions = [];

      if (options.file) {
        // Read descriptions from file
        const content = await fs.readFile(options.file, 'utf8');
        descriptions = content.split('\n\n').filter(desc => desc.trim());
        console.log(chalk.green(`‚úÖ Loaded ${descriptions.length} task descriptions from file`));
      } else if (options.interactive) {
        // Interactive mode
        console.log(chalk.yellow('Enter task descriptions. Type "done" to finish.\n'));

        let done = false;
        while (!done) {
          const { description } = await inquirer.prompt([
            {
              name: 'description',
              type: 'editor',
              message: 'Describe the task (press Enter to open editor):',
              validate: input => input.trim() !== '' || 'Description cannot be empty'
            }
          ]);

          if (description.toLowerCase().trim() === 'done') {
            done = true;
          } else {
            descriptions.push(description);
            console.log(chalk.green(`‚úÖ Task ${descriptions.length} added`));

            const { continue: shouldContinue } = await inquirer.prompt([
              {
                name: 'continue',
                type: 'confirm',
                message: 'Add another task?',
                default: true
              }
            ]);

            if (!shouldContinue) done = true;
          }
        }
      } else {
        // Single task mode from command line arguments
        const args = program.args.slice(1); // Skip 'describe' command
        if (args.length === 0) {
          console.log(chalk.yellow('Please provide a task description or use --interactive mode'));
          console.log(chalk.gray('\nExamples:'));
          console.log(chalk.gray('  nightly-code describe "Implement user authentication with email verification"'));
          console.log(chalk.gray('  nightly-code describe --interactive'));
          console.log(chalk.gray('  nightly-code describe --file tasks.txt'));
          process.exit(1);
        }
        descriptions = [args.join(' ')];
      }

      if (descriptions.length === 0) {
        console.log(chalk.yellow('No task descriptions provided'));
        process.exit(1);
      }

      // Process descriptions
      console.log(chalk.blue(`\nü§ñ Processing ${descriptions.length} task description(s)...`));

      let yamlContent;

      if (options.append && await fs.pathExists(options.output)) {
        // Load existing tasks
        const existingContent = await fs.readFile(options.output, 'utf8');
        const YAML = require('yaml');
        const existing = YAML.parse(existingContent);

        // Add new tasks
        const newTasks = descriptions.map(desc => {
          const task = taskDescriptor.parseDescription(desc);
          return taskDescriptor.optimizeTask(task);
        });

        existing.tasks = existing.tasks.concat(newTasks);

        // Sort all tasks by priority
        existing.tasks.sort((a, b) => b.priority - a.priority);

        yamlContent = YAML.stringify(existing, {
          indent: 2,
          lineWidth: 0
        });
      } else {
        // Generate new file
        yamlContent = taskDescriptor.generateTasksYaml(descriptions);
      }


      // Write output
      await fs.writeFile(options.output, yamlContent);
      console.log(chalk.green(`\n‚úÖ Tasks written to ${options.output}`));

      // Show summary
      const YAML = require('yaml');
      const tasks = YAML.parse(yamlContent).tasks;
      console.log(chalk.blue('\nüìä Task Summary:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      tasks.forEach((task, index) => {
        const priority = task.priority >= 8
          ? chalk.red(`[P${task.priority}]`)
          : task.priority >= 6
            ? chalk.yellow(`[P${task.priority}]`)
            : chalk.green(`[P${task.priority}]`);
        console.log(`${index + 1}. ${priority} ${task.title}`);
        console.log(
          `   Type: ${chalk.cyan(task.type)}, Duration: ${chalk.cyan(`${task.estimated_duration} min`)}, ` +
          `Tags: ${chalk.gray(task.tags.join(', '))}`
        );
      });

      const totalDuration = tasks.reduce((sum, task) => sum + task.estimated_duration, 0);
      console.log(chalk.gray('‚îÄ'.repeat(50)));
      console.log(chalk.blue(
        `Total estimated duration: ${Math.round(totalDuration / 60)} hours ${totalDuration % 60} minutes`
      ));

    } catch (error) {
      console.error(chalk.red('‚ùå Task description failed:'), error.message);
      process.exit(1);
    }
  });

// Error handling
program.on('command:*', () => {
  console.error(chalk.red(`Invalid command: ${program.args.join(' ')}`));
  console.log(chalk.yellow('See --help for available commands'));
  process.exit(1);
});

// Global error handler
process.on('uncaughtException', (error) => {
  console.error(chalk.red('‚ùå Uncaught Exception:'), error.message);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error(chalk.red('‚ùå Unhandled Rejection at:'), promise, 'reason:', reason);
  process.exit(1);
});

program.parse();
